""" MLP to Portfolio Performance Converter

Input:  A CSV file generated by exporting transaction data from an MLP bank account.
Output: A CSV file that can be imported by Portfolio Performance.
"""

import csv
import re         # regular expressions
import fileinput
import argparse   # command line arguments parser
import os
import sys

"""
Function definitions
"""

def opening_hook_csv(filename, mode):
	"""CSV opening hook for the fileinput.input() function.
	
	Opens the file with the given name and mode and returns the file pointer.
	It uses the universal newline mode returning any newline unchanged to the
	caller which is most suitable for CSV files.
	The encoding is fixed to the file encoding delivered my the MLP export.
	"""
	return open(filename, mode, newline='', encoding='iso-8859-1')

def printError(text):
	"""Print a red colored error text to stdout"""
	print('\033[31m Error: ' + text + '\033[0m')

def printWarning(text):
	"""Print an orange colored warning text to stdout"""
	print('\033[33m Warning: ' + text + '\033[0m')

def printSuccess(text):
	"""Print a green colored success message to stdout"""
	print('\033[32m Success: ' + text + '\033[0m')	

def findPieces(transactionText):
	"""Find the number of traded stock pieces in a transaction text

	Returns the number of pieces as a string if the number was found and an 
	empty string otherwise
	"""
	regex = r'MENGE\s+(\d+,?\d*)'
	matches = re.search(regex, transactionText)
	if matches:
		return matches.group(1)
	else:
		return ""

def findWkn(transactionText):
	"""Find the WKN in a transaction text

	Returns the WKN if it was found and an empty string otherwise
	"""
	regex = r'WKN (.*) /'
	matches = re.search(regex, transactionText)
	if matches:
		return matches.group(1)
	else:
		return ""

def findIsin(transactionText):
	"""Find the ISIN in a transaction text

	Returns the ISIN if it was found and an empty string otherwise
	"""
	regex = r'WKN.*/ ([0-9a-zA-Z]*)'
	matches = re.search(regex, transactionText)
	if matches:
		return matches.group(1)
	else:
		return ""

def findStockName(transactionText):
	"""Find and translate the stock name in a transaction text

	Returns the stock name if it was found and an empty string otherwise. The
	stock name is translated to a more readable string if the abbreviated 
	version is known. If it is unknown, the abbreviated string is returned.
	"""
	# Dictionary mapping abbreviated stock names to full stock names
	stockDict = {
		'ACATIS-GANE VAL.EV.F.UI A': 'Acatis Gané Value Event Fonds',
		'ISHS CORE DAX UCITS ETF'  : 'iShares Core DAX UCITS ETF',
		'ISHSIII-CORE MSCI WLD DLA': 'iShares Core MSCI World UCITS ETF',
		'CARMIGN.PATRIMOI. AEO ACC': 'Carmignac Patrimoine A',
		'THREADN.INV.-EU.S.C. RAEO': 'Threadneedle European Smaller Companies',
		'ETHNA-DEFENSIV INH. T'    : 'Ethna-Defensiv T EUR ACC'
	}

	regex = r'WKN.*\n(.*)\n'
	matches = re.search(regex, transactionText)
	if matches:
		name = matches.group(1)
		# The structure of the transaction has changed over time: the stock name
		# used to be in the line before the WKN but is now in the line after the
		# WKN. If the name contains "HANDELSTAG" we assume that we have an old
		# transcation text.	
		if(name.find('HANDELSTAG') != -1):
			# Old transaction text. We have to look before the WKN
			regex = r'(.*)\nWKN.*/.*\n'
			matches = re.search(regex, transactionText)
			if matches:
				name = matches.group(1)
			else:
				return ""	
	else:
		return ""

	# Try to translate the abbreviated name
	if name in stockDict:
		return stockDict[name]
	else:
		return name

def findTaxes(transactionText):
	"""Find tax amount in a transaction text

	Looks for tax substractions and returns the total amount of taxes if there
	are any, and 0 otherwise.
	"""
	kap = 0
	kapRegex = r'KAPST\s+(.*)-'
	matches = re.search(kapRegex, transactionText)
	if matches:
		kapStr = matches.group(1)
		kap = float(kapStr.replace(',', '.'))

	soli = 0
	soliRegex = r'SOLZ\s+(.*)-'
	matches = re.search(soliRegex, transactionText)
	if matches:
		soliStr = matches.group(1)
		soli = float(soliStr.replace(',', '.'))

	return kap + soli

"""
Main program
"""

# Define and parse command line arguments
argParser = argparse.ArgumentParser()
argParser.add_argument("infile",
	help="Input CSV file from MLP bank")
argParser.add_argument("-o", "--outfile",
	help="Name of the converted ouput CSV file")
argParser.add_argument("-s", "--skip-lines",
	help="Number of header lines to skip in input file",
	type=int,
	default=12)
commandArgs = argParser.parse_args()

# Check wheter input file exists
inputFile = commandArgs.infile
if (not os.path.exists(inputFile)):
	printError("Input file \"" + inputFile + "\" does not exist")
	sys.exit(1)
# Number of lines to skip. The first line after skipping should contain the 
# column headers aka field names.
numSkipLines = commandArgs.skip_lines
if (numSkipLines < 0):
	printError("SKIP_LINES must not be negative. Found: " + str(numSkipLines))
	sys.exit(1)
# Name of converted output file
if (commandArgs.outfile == None):
	infileBase, infileExt = os.path.splitext(inputFile)
	outputFile = infileBase + "_converted" + infileExt
else:
	outputFile = commandArgs.outfile

# Open the input file and skip header lines. We use the fileinput module here
# because it provides a function to get the current line number in the file.
csvInput = fileinput.input(files=inputFile, mode='r', openhook=opening_hook_csv)
for foo in range(numSkipLines):
	next(csvInput)

# Open the output file
csvOutput = open(outputFile, 'w', newline='')

# Read the CSV file as Dictionary. The first line contains the field names
# defining the keys of the Dictionary.
transactionReader = csv.DictReader(csvInput, delimiter=';', quotechar='"')

# Create the CSV writer for the ouput file and write the header line
fieldNames = ['Datum', 'Typ', 'Wert', 'Buchungswährung', 'Steuern', 'Stück', 'ISIN', 'WKN', 'Ticker-Symbol', 'Wertpapiername', 'Notiz']
transactionWriter = csv.DictWriter(csvOutput, fieldnames=fieldNames, delimiter=';')
transactionWriter.writeheader()

# Regular expressions to find categories of transactions
depositRe  = re.compile(r'LASTSCHRIFTEINR\.\n')
sellRe     = re.compile(r'EFFEKTENGUTSCHRIFT\nWERTPAPIERABRECHNUNG\nVERKAUF')
sellOldRe  = re.compile(r'EFFEKTENGUTSCHRIFT\nDEPOT.*\nWERTPAPIERABRECHNUNG')
taxRetRe   = re.compile(r'EFFEKTENGUTSCHRIFT\nWERTPAPIERABRECHNUNG\nKAUF\nSTEUERAUSGLEICH')
dividendRe = re.compile(r'EFFEKTENGUTSCHRIFT\nWP-ERTRÄGNISGUTSCHRIFT\nINVESTMENTFONDS')
buyRe      = re.compile(r'EFFEKTEN\n')
collectRe  = re.compile(r'EINZUGSERMAECHTIGUNG\n')
creditRe   = re.compile(r'GUTSCHRIFT\n')
soliTaxRe  = re.compile(r'SOLIDARITÄTSZUSCHLAG\n')
kapiTaxRe  = re.compile(r'KAPITALERTRAGSTEUER\n')
transRe    = re.compile(r'UEBERWEISUNG\n')

rowCnt = 0
for row in transactionReader:
	# Create output dictionary and set values that are independent of the 
	# transaction type.
	outDict = {}
	outDict['Datum']           = row['Valuta']
	outDict['Wert']            = row['Umsatz']
	outDict['Buchungswährung'] = 'EUR'

	transactionIsValid = True
	subjectStr = row['Vorgang/Verwendungszweck']
	
	# Determine output values that depend on the transaction type	
	if(depositRe.match(subjectStr) != None):		
		if(subjectStr.find('SPARPLAN') != -1):
			outDict['Notiz'] = 'Sparplan'
		outDict['Typ'] = 'Einlage'
	
	elif(sellRe.match(subjectStr) or sellOldRe.match(subjectStr)):
		pieces = findPieces(subjectStr)
		if(pieces == ""):
			printWarning("Could not find number of pieces in line " + str(csvInput.filelineno()))
			transactionIsValid = False
		wkn = findWkn(subjectStr)
		if(wkn == ""):
			printWarning("Could not find WKN in line " + str(csvInput.filelineno()))
			# We can still use the transaction
		isin = findIsin(subjectStr)
		if(isin == ""):
			printWarning("Could not find ISIN in line " + str(csvInput.filelineno()))
			# We can still use the transaction
		name = findStockName(subjectStr)
		if(name == ""):
			printWarning("Could not find the stock name in line ") + str(csvInput.filelineno())
			transactionIsValid = False
		taxes = findTaxes(subjectStr)
		if transactionIsValid:
			outDict['Typ']            = 'Verkauf'
			outDict['Stück']          = pieces
			outDict['WKN']            = wkn
			outDict['ISIN']           = isin
			outDict['Wertpapiername'] = name
			outDict['Steuern']        = str(taxes)

	elif(taxRetRe.match(subjectStr) != None):
		outDict['Typ']   = 'Steuerrückerstattung'
		outDict['Notiz'] = 'Steuerausgleich'

	elif(dividendRe.match(subjectStr) != None):
		outDict['Typ']   = 'Steuerrückerstattung'
		outDict['Notiz'] = 'Erträgnisgutschrift'

	elif(buyRe.match(subjectStr) != None):
		pieces = findPieces(subjectStr)
		if(pieces == ""):
			printWarning("Could not find number of pieces in line " + str(csvInput.filelineno()))
			transactionIsValid = False
		wkn = findWkn(subjectStr)
		if(wkn == ""):
			printWarning("Could not find WKN in line " + str(csvInput.filelineno()))
			# We can still use the transaction
		isin = findIsin(subjectStr)
		if(isin == ""):
			printWarning("Could not find ISIN in line " + str(csvInput.filelineno()))
			# We can still use the transaction
		name = findStockName(subjectStr)
		if(name == ""):
			printWarning("Could not find the stock name in line ") + str(csvInput.filelineno())
			transactionIsValid = False
		if transactionIsValid:
			outDict['Typ']            = 'Kauf'
			outDict['Stück']          = pieces
			outDict['WKN']            = wkn
			outDict['ISIN']           = isin
			outDict['Wertpapiername'] = name

	elif(collectRe.match(subjectStr) != None):
		if(subjectStr.find('DEPOTENTGELT') != -1):
			outDict['Typ']   = 'Gebühren'
			outDict['Notiz'] = 'Depotgebühr'
		else:
			outDict['Typ']   = 'Entnahme'
			outDict['Notiz'] = 'Unbekannte Abbuchung'

	elif(creditRe.match(subjectStr) != None):
		outDict['Typ'] = 'Gebührenerstattung'
		if(subjectStr.find('VERTRIEBSFOLGEPROVISION') != -1):
			outDict['Notiz'] = 'Erstattung Vertriebsfolgeprovision'
		else:
			outDict['Notiz'] = 'Unbekannte Gutschrift'
		
	elif(soliTaxRe.match(subjectStr) != None):
		outDict['Typ']   = 'Steuern'
		outDict['Notiz'] = 'Solidaritätszuschlag'

	elif(kapiTaxRe.match(subjectStr) != None):
		outDict['Typ']   = 'Steuern'
		outDict['Notiz'] = 'Kapitalertragsteuer'
		
	elif(transRe.match(subjectStr)):
		outDict['Typ'] = 'Entnahme'

	else:
		printWarning("Unknown transaction type in line " + str(csvInput.filelineno()))
		transactionIsValid = False

	# Write out the converted row
	if (transactionIsValid):
		transactionWriter.writerow(outDict)
		rowCnt += 1

printSuccess("Converted " + str(rowCnt) + " transactions")

# Close the files
csvInput.close()
csvOutput.close()